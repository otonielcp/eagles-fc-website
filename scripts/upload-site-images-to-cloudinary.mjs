#!/usr/bin/env node
/**
 * Upload all site images from public/ to Cloudinary (folder: eagles-fc/site).
 * Writes lib/site-images.generated.json with { "/path": "https://res.cloudinary.com/..." }.
 *
 * Requires .env with:
 *   NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME
 *   CLOUDINARY_API_KEY
 *   CLOUDINARY_API_SECRET
 *
 * Run: node scripts/upload-site-images-to-cloudinary.mjs
 * Or:  npm run upload-site-images
 */

import { readFileSync, readdirSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { v2 as cloudinary } from 'cloudinary';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, '..');
const PUBLIC = join(ROOT, 'public');
const OUTPUT = join(ROOT, 'lib', 'site-images.generated.ts');

const IMG_EXT = new Set(['.png', '.jpg', '.jpeg', '.gif', '.webp', '.JPG', '.JPEG', '.PNG', '.GIF', '.WEBP']);

function loadEnvFile(path, overwrite = false) {
  try {
    const raw = readFileSync(path, 'utf8');
    for (const line of raw.split(/\n/)) {
      const m = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$/);
      if (m) {
        const v = m[2].replace(/^["']|["']\s*$/g, '').trim();
        if (overwrite || !process.env[m[1]]) process.env[m[1]] = v;
      }
    }
  } catch (_) {}
}

function loadEnv() {
  loadEnvFile(join(ROOT, '.env'));
  loadEnvFile(join(ROOT, '.env.local'), true);
  const { NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET } = process.env;
  if (!NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME || !CLOUDINARY_API_KEY || !CLOUDINARY_API_SECRET) {
    throw new Error('Missing Cloudinary env. Add NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET to .env or .env.local');
  }
  cloudinary.config({
    cloud_name: NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
    api_key: CLOUDINARY_API_KEY,
    api_secret: CLOUDINARY_API_SECRET,
  });
}

function collectImages(dir, base = '') {
  const out = [];
  const entries = readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const rel = base ? `${base}/${e.name}` : e.name;
    const full = join(dir, e.name);
    if (e.isDirectory()) {
      out.push(...collectImages(full, rel));
    } else if (e.isFile() && IMG_EXT.has(rel.slice(rel.lastIndexOf('.')))) {
      out.push(rel.replace(/\\/g, '/'));
    }
  }
  return out;
}

function toPublicId(relPath) {
  return `site-${relPath.replace(/\//g, '_').replace(/\s+/g, '_').replace(/\.(png|jpg|jpeg|gif|webp)$/i, '')}`;
}

async function uploadOne(relPath) {
  const full = join(PUBLIC, relPath);
  const buf = readFileSync(full);
  const ext = relPath.slice(relPath.lastIndexOf('.'));
  const mime = { '.png': 'image/png', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.gif': 'image/gif', '.webp': 'image/webp' }[ext.toLowerCase()] || 'image/jpeg';
  const b64 = `data:${mime};base64,${buf.toString('base64')}`;
  const result = await cloudinary.uploader.upload(b64, {
    folder: 'eagles-fc/site',
    public_id: toPublicId(relPath),
    resource_type: 'image',
    overwrite: true,
  });
  return result.secure_url;
}

async function main() {
  loadEnv();
  const images = collectImages(PUBLIC);
  console.log(`Found ${images.length} images in public/`);

  const map = {};
  for (let i = 0; i < images.length; i++) {
    const rel = images[i];
    const key = '/' + rel;
    try {
      const url = await uploadOne(rel);
      map[key] = url;
      console.log(`[${i + 1}/${images.length}] ${key} -> Cloudinary`);
    } catch (err) {
      console.error(`Failed ${key}:`, err.message);
    }
  }

  const libDir = join(ROOT, 'lib');
  try { mkdirSync(libDir, { recursive: true }); } catch (_) {}
  const ts = `/** Auto-generated by scripts/upload-site-images-to-cloudinary.mjs */\n\nexport const SITE_IMAGES: Record<string, string> = ${JSON.stringify(map, null, 2)};\n`;
  writeFileSync(OUTPUT, ts, 'utf8');
  console.log(`Wrote ${OUTPUT}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
